---
# The name of your system
title: "Euterpe"
subtitle: "An AI music interaction system framework"

# Set the correct flags based on the type of your music interaction algorithm
# Any combination is valid
noteBasedMode: 
  # If eventBased: true, then the worker's processNoteEvent() hook is active
  # for instant processing of each user's MIDI event.
  eventBased: false
  # If clockBased: true, then the worker's processEventsBuffer() hook is active
  # for processing raw and quantized MIDI events buffers at every "clock-tick"
  # If clockBased = false, the processEventsBuffer() is not active, but we still
  # create a clock to "power" the scrolling functionality of the PianoRoll and Score UIs
  clockBased: true

# If audioBasedMode = true, the worker's processAudioBuffer() hook is active.
audioBasedMode: false

# The settings for the clockBased operation.
# These are taken into account only if clockBased: true
clockBasedSettings:
  ticksPerBeat: 4 # use that for 16th-note grid on 4/4
  timeSignature:
    numerator: 4
    denominator: 4
  # BPM. tempo + ticksPerBeat are used to determine the clockPeriod
  # This is just the default value. The user can later change it
  # from the settings menu (effectively changing the clock's period)
  tempo: 60
  # Set the clockPeriod explicitly (milliseconds)
  # if used, the ticksPerBeat, timeSignature and tempo are ignored
  # Use only if your music interaction algorithm
  # operates on a "free-time" mode (no BPM or timeSignature)
  clockPeriod: null
  # Choose what information you want Euterpe to provide to your algorithm (Worker)
  # at every clock-tick
  eventBuffer: true # A buffer with all the MIDI events played by the user since the last tick
  quantizedEvents: true # Only the quantized MIDI events that correspond to the current tick. 
    
# Set the polyphony that your music algorithm supports. Euterpe limits the user's input polyphony
# so that you don't have to do it. Currently, it only applies to the quantizedEvents (clockBased mode)
polyphony:
  input: 1
  output: 1

# Worker related settings.
workerSettings:
  # For Workers that require warmup (such as neural networks)
  warmupRounds: 2
  # Many music interaction algorithms support controlling their output randomness 
  # (e.g., sampling temperature).
  # Default value for randomness(stochasticity) is 0, and is controlled by a slider
  # within the settings tab. (max=1)
  randomness: 0

# Choose the text to be displayed in the splash screen animation
introModal: true
introModalContent:
  - "Hi! This is Euterpe."
  - "I am a web-framework for music interaction systems."

# # Voices: integer, denotes the number of voices for input and output.
# polyphony:
#   input: 1
#   output: 1

# mode: "grid" # or "continuous"

# # if eventBased is set to true, the worker will also receive midi events (note on and note off) the moment they happen without any delay.
# eventBased: false
# ticksPerBeat: 4
# timeSignature:
#   numerator: 4
#   denominator: 4
# tempo: 60
# # In general, clockPeriod will be determined by Euterpe using tempo and ticksPerBeat
# # if you manually choose a value for clockPeriod ... then what ? 
# # clockPeriod: null

# # Worker specific values
# worker:
#   warmupRounds: 2
#   randomness: 0



#  // // FROM Yongyi's yaml I get
# // const MODE = "GRID"; // or "CONTINUOUS"
# // // If GRID, then we need BPM, GRID, TS_NOM, TS_DEN
# // // If CONTINUOUS, then we need PERIOD
# // const BPM = 90;
# // const TICKS_PER_BEAT = 4; // this is the number of ticks per beat
# // const TS_NOM = 4; // this is the numerator of the time signature
# // const TS_DEN = 4; // this is the denominator of the time signature
# // let CLOCK_PERIOD = null;
# // let TICKS_PER_MEASURE = null;
# // let GRID_TICK_PERIOD = null;
# // let QUANTIZED_BUFFER_SIZE = null;
# // if (MODE === "GRID") {
# //     // in GRID mode, the clock period is the same as the grid tick duration
# //     // for example if we have a 4/4 time signature, and a 16th note grid, then
# //     // the grid tick duration is 60 / 90 / 4 = 0.25 seconds
# //     // and the clock ticks every 0.25 seconds as well
# //     GRID_TICK_PERIOD = (60 / BPM / TICKS_PER_BEAT) * 1000;
# //     CLOCK_PERIOD = GRID_TICK_PERIOD;
# //     TICKS_PER_MEASURE = TS_NOM * TICKS_PER_BEAT;
# //     // In GRID mode, the quantized buffer size is the same as the number of ticks per measure
# //     QUANTIZED_BUFFER_SIZE = TICKS_PER_MEASURE;
# // }
# // else if (MODE === "CONTINUOUS") {
# //     // CLOCK_PERIOD needs not to be null.
# //     if (CLOCK_PERIOD === null) {
# //         throw new Error("CLOCK_PERIOD cannot be null in CONTINUOUS mode.");
# //     }
# //     GRID_TICK_PERIOD = CLOCK_PERIOD;
# //     // In CONTINUOUS mode, the quant buffer size doesn't have any physical meaning,
# //     // I just set it to 16 for now
# //     QUANTIZED_BUFFER_SIZE = 16;
# // }