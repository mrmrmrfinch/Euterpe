{"version":3,"file":"index.js","sources":["../js/audioqueue.js","../js/param.js","../js/ringbuf.js"],"sourcesContent":["/**\n * Interleaved -> Planar audio buffer conversion\n *\n * This is useful to get data from a codec, the network, or anything that is\n * interleaved, into a planar format, for example a Web Audio API AudioBuffer or\n * the output parameter of an AudioWorkletProcessor.\n *\n * @param {Float32Array} input is an array of n*128 frames arrays, interleaved,\n * where n is the channel count.\n * @param {Float32Array} output is an array of 128-frames arrays.\n */\nexport function deinterleave(input, output) {\n  var channel_count = input.length / 256;\n  if (output.length != channel_count) {\n    throw \"not enough space in output arrays\";\n  }\n  for (var i = 0; i < channelCount; i++) {\n    let out_channel = output[i];\n    let interleaved_idx = i;\n    for (var j = 0; j < 128; ++j) {\n      out_channel[j] = input[interleaved_idx];\n      interleaved_idx += channel_count;\n    }\n  }\n}\n\n/**\n * Planar -> Interleaved audio buffer conversion\n *\n * This function is useful to get data from the Web Audio API (that uses a\n * planar format), into something that a codec or network streaming library\n * would expect.\n *\n * @param {Float32Array} input An array of n*128 frames Float32Array that hold the audio data.\n * @param {Float32Array} output A Float32Array that is n*128 elements long.\n */\nexport function interleave(input, output) {\n  if (input.length * 128 != output.length) {\n    throw \"input and output of incompatible sizes\";\n  }\n  var out_idx = 0;\n  for (var i = 0; i < 128; i++) {\n    for (var channel = 0; channel < input.length; channel++) {\n      output[out_idx] = input[channel][i];\n      out_idx++;\n    }\n  }\n}\n\n/**\n * Send interleaved audio frames to another thread, wait-free.\n *\n * These classes allow communicating between a non-real time thread (browser\n * main thread or worker) and a real-time thread (in an AudioWorkletProcessor).\n * Write and Reader cannot change role after setup, unless externally\n * synchronized.\n *\n * GC _can_ happen during the initial construction of this object when hopefully\n * no audio is being output. This depends on how implementations schedule GC\n * passes. After the setup phase no GC is triggered on either side of the queue.\n */\nexport class AudioWriter {\n  /**\n   * From a RingBuffer, build an object that can enqueue enqueue audio in a ring\n   * buffer.\n   * @constructor\n   */\n  constructor(ringbuf) {\n    if (ringbuf.type() != \"Float32Array\") {\n      throw \"This class requires a ring buffer of Float32Array\";\n    }\n    this.ringbuf = ringbuf;\n  }\n  /**\n   * Enqueue a buffer of interleaved audio into the ring buffer.\n   *\n   *\n   * Care should be taken to enqueue a number of samples that is a multiple of the\n   * channel count of the audio stream.\n   *\n   * @param {Float32Array} buf An array of interleaved audio frames.\n   *\n   * @return The number of samples that have been successfuly written to the\n   * queue. `buf` is not written to during this call, so the samples that\n   * haven't been written to the queue are still available.\n   */\n  enqueue(buf) {\n    return this.ringbuf.push(buf);\n  }\n\n  /**\n   * @return The free space in the ring buffer. This is the amount of samples\n   * that can be queued, with a guarantee of success.\n   */\n  available_write() {\n    return this.ringbuf.available_write();\n  }\n}\n\n/**\n * Receive interleaved audio frames to another thread, wait-free.\n *\n * GC _can_ happen during the initial construction of this object when hopefully\n * no audio is being output. This depends on how implementations schedule GC\n * passes. After the setup phase no GC is triggered on either side of the queue.\n */\nexport class AudioReader {\n  /**\n   * From a RingBuffer, build an object that can dequeue audio in a ring\n   * buffer.\n   * @constructor\n   */\n  constructor(ringbuf) {\n    if (ringbuf.type() != \"Float32Array\") {\n      throw \"This class requires a ring buffer of Float32Array\";\n    }\n    this.ringbuf = ringbuf;\n  }\n  /**\n   * Attempt to dequeue at most `buf.length` samples from the queue. This\n   * returns the number of samples dequeued. If greater than 0, the samples are\n   * at the beginning of `buf`.\n   *\n   * Care should be taken to dequeue a number of samples that is a multiple of the\n   * channel count of the audio stream.\n   *\n   * @param {Float32Array} buf A buffer in which to copy the dequeued\n   * interleaved audio frames.\n   * @return The number of samples dequeued.\n   */\n  dequeue(buf) {\n    if (this.ringbuf.empty()) {\n      return 0;\n    }\n    return this.ringbuf.pop(buf);\n  }\n  /**\n   * Query the occupied space in the queue. \n   *\n   * @return The amount of samples that can be read with a guarantee of success.\n   *\n   */\n  available_read() {\n    return this.ringbuf.available_read();\n  }\n}\n","/**\n * Send parameter changes, lock free, no gc, between a UI thread (browser\n * main thread or worker) and a real-time thread (in an AudioWorkletProcessor).\n * Write and Reader cannot change role after setup, unless externally\n * synchronized.\n *\n * GC _can_ happen during the initial construction of this object when hopefully\n * no audio is being output. This depends on the implementation.\n *\n * Parameter changes are like in the VST framework: an index and a float value\n * (no restriction on the value).\n *\n * This class supports up to 256 parameters, but this is easy to extend if\n * needed.\n *\n * An element is an index, that is an unsigned byte, and a float32, which is 4\n * bytes.\n */\nexport class ParameterWriter {\n  /**\n   * From a RingBuffer, build an object that can enqueue a parameter change in\n   * the queue.\n   * @param {RingBuffer} ringbuf A RingBuffer object of Uint8Array.\n   * @constructor\n   */\n  constructor(ringbuf) {\n    if (ringbuf.type() != \"Uint8Array\") {\n      throw \"This class requires a ring buffer of Uint8Array\";\n    }\n    const SIZE_ELEMENT = 5;\n    this.ringbuf = ringbuf;\n    this.mem = new ArrayBuffer(SIZE_ELEMENT);\n    this.array = new Uint8Array(this.mem);\n    this.view = new DataView(this.mem);\n  }\n  /*\n   * Enqueue a parameter change for parameter of index `index`, with a new value\n   * of `value`.\n   *\n   * @param {number} index The index of the parameter.\n   * @param {number} value The value of the parameter.\n   * @return True if enqueuing suceeded, false otherwise.\n   */\n  enqueue_change(index, value) {\n    const SIZE_ELEMENT = 5;\n    this.view.setUint8(0, index);\n    this.view.setFloat32(1, value);\n    if (this.ringbuf.available_write() < SIZE_ELEMENT) {\n      return false;\n    }\n    return this.ringbuf.push(this.array) == SIZE_ELEMENT;\n  }\n}\n\n/**\n * Receive parameter changes, lock free, no gc, between a UI thread (browser\n * main thread or worker) and a real-time thread (in an AudioWorkletProcessor).\n * Write and Reader cannot change role after setup, unless externally\n * synchronized.\n *\n * GC _can_ happen during the initial construction of this object when hopefully\n * no audio is being output. This depends on the implementation.\n *\n * Parameter changes are like in the VST framework: an index and a float value\n * (no restriction on the value).\n *\n * This class supports up to 256 parameters, but this is easy to extend if\n * needed.\n *\n * An element is an index, that is an unsigned byte, and a float32, which is 4\n * bytes.\n */\nexport class ParameterReader {\n  /**\n   * @constructor\n   * @param {RingBuffer} ringbuf A RingBuffer setup to hold Uint8.\n  */\n  constructor(ringbuf) {\n    const SIZE_ELEMENT = 5;\n    this.ringbuf = ringbuf;\n    this.mem = new ArrayBuffer(SIZE_ELEMENT);\n    this.array = new Uint8Array(this.mem);\n    this.view = new DataView(this.mem);\n  }\n  /**\n   * Attempt to dequeue a single parameter change.\n   * @param {Object} o An object with two attributes: `index` and `value`.\n   * @return true if a parameter change has been dequeued, false otherwise.\n   */\n  dequeue_change(o) {\n    if (this.ringbuf.empty()) {\n      return false;\n    }\n    var rv = this.ringbuf.pop(this.array);\n    o.index = this.view.getUint8(0);\n    o.value = this.view.getFloat32(1);\n\n    return true;\n  }\n}\n","/** The base RingBuffer class\n *\n * A Single Producer - Single Consumer thread-safe wait-free ring buffer.\n *\n * The producer and the consumer can be on separate threads, but cannot change roles,\n * except with external synchronization.\n */\nexport class RingBuffer {\n  /** Allocate the SharedArrayBuffer for a RingBuffer, based on the type and\n   * capacity required\n   * @param {number} capacity The number of elements the ring buffer will be\n   * able to hold.\n   * @param {TypedArray} type A typed array constructor, the type that this ring\n   * buffer will hold.\n   * @return {SharedArrayBuffer} A SharedArrayBuffer of the right size.\n   * @static\n   */\n  static getStorageForCapacity(capacity, type) {\n    if (!type.BYTES_PER_ELEMENT) {\n      throw \"Pass in a ArrayBuffer subclass\";\n    }\n    var bytes = 8 + (capacity + 1) * type.BYTES_PER_ELEMENT;\n    return new SharedArrayBuffer(bytes);\n  }\n  /**\n   * @constructor\n   * @param {SharedArrayBuffer} sab A SharedArrayBuffer obtained by calling\n   * {@link RingBuffer.getStorageFromCapacity}.\n   * @param {TypedArray} type A typed array constructor, the type that this ring\n   * buffer will hold.\n   */\n  constructor(sab, type) {\n    if (!ArrayBuffer.__proto__.isPrototypeOf(type) &&\n      type.BYTES_PER_ELEMENT !== undefined) {\n      throw \"Pass a concrete typed array class as second argument\";\n    }\n\n    // Maximum usable size is 1<<32 - type.BYTES_PER_ELEMENT bytes in the ring\n    // buffer for this version, easily changeable.\n    // -4 for the write ptr (uint32_t offsets)\n    // -4 for the read ptr (uint32_t offsets)\n    // capacity counts the empty slot to distinguish between full and empty.\n    this._type = type;\n    this._capacity = (sab.byteLength - 8) / type.BYTES_PER_ELEMENT;\n    this.buf = sab;\n    this.write_ptr = new Uint32Array(this.buf, 0, 1);\n    this.read_ptr = new Uint32Array(this.buf, 4, 1);\n    this.storage = new type(this.buf, 8, this._capacity);\n  }\n  /**\n   * @return the type of the underlying ArrayBuffer for this RingBuffer. This\n   * allows implementing crude type checking.\n   */\n  type() {\n    return this._type.name;\n  }\n\n  /**\n   * Push elements to the ring buffer.\n   * @param {TypedArray} elements A typed array of the same type as passed in the ctor, to be written to the queue.\n   * @param {Number} length If passed, the maximum number of elements to push.\n   * If not passed, all elements in the input array are pushed.\n   * @return the number of elements written to the queue.\n   */\n  push(elements, length) {\n    var rd = Atomics.load(this.read_ptr, 0);\n    var wr = Atomics.load(this.write_ptr, 0);\n\n    if ((wr + 1) % this._storage_capacity() == rd) {\n      // full\n      return 0;\n    }\n\n    var len = length != undefined ? length : elements.length;\n\n    let to_write = Math.min(this._available_write(rd, wr), len);\n    let first_part = Math.min(this._storage_capacity() - wr, to_write);\n    let second_part = to_write - first_part;\n\n    this._copy(elements, 0, this.storage, wr, first_part);\n    this._copy(elements, first_part, this.storage, 0, second_part);\n\n    // publish the enqueued data to the other side\n    Atomics.store(\n      this.write_ptr,\n      0,\n      (wr + to_write) % this._storage_capacity()\n    );\n\n    return to_write;\n  }\n\n  /**\n   * Write bytes to the ring buffer using callbacks. This create wrapper\n   * objects and can GC, so it's best to no use this variant from a real-time\n   * thread such as an AudioWorklerProcessor `process` method.\n   * The callback is passed two typed arrays of the same type, to be filled.\n   * This allows skipping copies if the API that produces the data writes is\n   * passed arrays to write to, such as `AudioData.copyTo`.\n   * @param {number} amount The maximum number of elements to write to the ring\n   * buffer. If amount is more than the number of slots available for writing,\n    * then the number of slots available for writing will be made available: no\n    * overwriting of elements can happen.\n    * @param {Function} cb A callback with two parameters, that are two typed\n    * array of the correct type, in which the data need to be copied. It is\n    * necessary to write exactly the number of elements determined by the size\n    * of the two typed arrays.\n    * @return The number of elements written to the queue.\n   */\n  writeCallback(amount, cb) {\n    var rd = Atomics.load(this.read_ptr, 0);\n    var wr = Atomics.load(this.write_ptr, 0);\n\n    if ((wr + 1) % this._storage_capacity() == rd) {\n      // full\n      return 0;\n    }\n\n    let to_write = Math.min(this._available_write(rd, wr), amount);\n    let first_part = Math.min(this._storage_capacity() - wr, to_write);\n    let second_part = to_write - first_part;\n\n    // This part will cause GC: don't use in the real time thread.\n    var first_part_buf = new this._type(this.storage.buffer, 8 + wr * 4, first_part);\n    var second_part_buf = new this._type(this.storage.buffer, 8 + 0, second_part);\n\n    cb(first_part_buf, second_part_buf);\n\n    // publish the enqueued data to the other side\n    Atomics.store(\n      this.write_ptr,\n      0,\n      (wr + to_write) % this._storage_capacity()\n    );\n\n    return to_write;\n  }\n\n  /**\n   * Read up to `elements.length` elements from the ring buffer. `elements` is a typed\n   * array of the same type as passed in the ctor.\n   * Returns the number of elements read from the queue, they are placed at the\n   * beginning of the array passed as parameter.\n   * @param {TypedArray} elements An array in which the elements read from the\n   * queue will be written, starting at the beginning of the array.\n   * @param {Number} length If passed, the maximum number of elements to pop. If\n   * not passed, up to elements.length are popped.\n   * @return The number of elements read from the queue.\n   */\n  pop(elements, length) {\n    var rd = Atomics.load(this.read_ptr, 0);\n    var wr = Atomics.load(this.write_ptr, 0);\n\n    if (wr == rd) {\n      return 0;\n    }\n\n    var len = length != undefined ? length : elements.length;\n\n    let to_read = Math.min(this._available_read(rd, wr), len);\n\n    let first_part = Math.min(this._storage_capacity() - rd, to_read);\n    let second_part = to_read - first_part;\n\n    this._copy(this.storage, rd, elements, 0, first_part);\n    this._copy(this.storage, 0, elements, first_part, second_part);\n\n    Atomics.store(this.read_ptr, 0, (rd + to_read) % this._storage_capacity());\n\n    return to_read;\n  }\n\n  /**\n   * @return True if the ring buffer is empty false otherwise. This can be late\n   * on the reader side: it can return true even if something has just been\n   * pushed.\n   */\n  empty() {\n    var rd = Atomics.load(this.read_ptr, 0);\n    var wr = Atomics.load(this.write_ptr, 0);\n\n    return wr == rd;\n  }\n\n  /**\n   * @return True if the ring buffer is full, false otherwise. This can be late\n   * on the write side: it can return true when something has just been popped.\n   */\n  full() {\n    var rd = Atomics.load(this.read_ptr, 0);\n    var wr = Atomics.load(this.write_ptr, 0);\n\n    return (wr + 1) % this._storage_capacity() == rd;\n  }\n\n  /**\n   * @return The usable capacity for the ring buffer: the number of elements\n   * that can be stored.\n   */\n  capacity() {\n    return this._capacity - 1;\n  }\n\n  /**\n   * @return The number of elements available for reading. This can be late, and\n   * report less elements that is actually in the queue, when something has just\n   * been enqueued.\n   */\n  available_read() {\n    var rd = Atomics.load(this.read_ptr, 0);\n    var wr = Atomics.load(this.write_ptr, 0);\n    return this._available_read(rd, wr);\n  }\n\n  /**\n   * @return The number of elements available for writing. This can be late, and\n   * report less elements that is actually available for writing, when something\n   * has just been dequeued.\n   */\n  available_write() {\n    var rd = Atomics.load(this.read_ptr, 0);\n    var wr = Atomics.load(this.write_ptr, 0);\n    return this._available_write(rd, wr);\n  }\n\n  // private methods //\n\n  /**\n   * @return Number of elements available for reading, given a read and write\n   * pointer.\n   * @private\n   */\n  _available_read(rd, wr) {\n    return (wr + this._storage_capacity() - rd) % this._storage_capacity();\n  }\n\n  /**\n   * @return Number of elements available from writing, given a read and write\n   * pointer.\n   * @private\n   */\n  _available_write(rd, wr) {\n    return this.capacity() - this._available_read(rd, wr);\n  }\n\n  /**\n   * @return The size of the storage for elements not accounting the space for\n   * the index, counting the empty slot.\n   * @private\n   */\n  _storage_capacity() {\n    return this._capacity;\n  }\n\n  /**\n   * Copy `size` elements from `input`, starting at offset `offset_input`, to\n   * `output`, starting at offset `offset_output`.\n   * @param {TypedArray} input The array to copy from\n   * @param {Number} offset_input The index at which to start the copy\n   * @param {TypedArray} output The array to copy to\n   * @param {Number} offset_output The index at which to start copying the elements to\n   * @param {Number} size The number of elements to copy\n   * @private\n   */\n  _copy(input, offset_input, output, offset_output, size) {\n    for (var i = 0; i < size; i++) {\n      output[offset_output + i] = input[offset_input + i];\n    }\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,YAAY,CAAC,KAAK,EAAE,MAAM,EAAE;AAC5C,EAAE,IAAI,aAAa,GAAG,KAAK,CAAC,MAAM,GAAG,GAAG,CAAC;AACzC,EAAE,IAAI,MAAM,CAAC,MAAM,IAAI,aAAa,EAAE;AACtC,IAAI,MAAM,mCAAmC,CAAC;AAC9C,GAAG;AACH,EAAE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,YAAY,EAAE,CAAC,EAAE,EAAE;AACzC,IAAI,IAAI,WAAW,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;AAChC,IAAI,IAAI,eAAe,GAAG,CAAC,CAAC;AAC5B,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,EAAE,CAAC,EAAE;AAClC,MAAM,WAAW,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,eAAe,CAAC,CAAC;AAC9C,MAAM,eAAe,IAAI,aAAa,CAAC;AACvC,KAAK;AACL,GAAG;AACH,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,UAAU,CAAC,KAAK,EAAE,MAAM,EAAE;AAC1C,EAAE,IAAI,KAAK,CAAC,MAAM,GAAG,GAAG,IAAI,MAAM,CAAC,MAAM,EAAE;AAC3C,IAAI,MAAM,wCAAwC,CAAC;AACnD,GAAG;AACH,EAAE,IAAI,OAAO,GAAG,CAAC,CAAC;AAClB,EAAE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;AAChC,IAAI,KAAK,IAAI,OAAO,GAAG,CAAC,EAAE,OAAO,GAAG,KAAK,CAAC,MAAM,EAAE,OAAO,EAAE,EAAE;AAC7D,MAAM,MAAM,CAAC,OAAO,CAAC,GAAG,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1C,MAAM,OAAO,EAAE,CAAC;AAChB,KAAK;AACL,GAAG;AACH,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAM,WAAW,CAAC;AACzB;AACA;AACA;AACA;AACA;AACA,EAAE,WAAW,CAAC,OAAO,EAAE;AACvB,IAAI,IAAI,OAAO,CAAC,IAAI,EAAE,IAAI,cAAc,EAAE;AAC1C,MAAM,MAAM,mDAAmD,CAAC;AAChE,KAAK;AACL,IAAI,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;AAC3B,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,OAAO,CAAC,GAAG,EAAE;AACf,IAAI,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AAClC,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,EAAE,eAAe,GAAG;AACpB,IAAI,OAAO,IAAI,CAAC,OAAO,CAAC,eAAe,EAAE,CAAC;AAC1C,GAAG;AACH,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAM,WAAW,CAAC;AACzB;AACA;AACA;AACA;AACA;AACA,EAAE,WAAW,CAAC,OAAO,EAAE;AACvB,IAAI,IAAI,OAAO,CAAC,IAAI,EAAE,IAAI,cAAc,EAAE;AAC1C,MAAM,MAAM,mDAAmD,CAAC;AAChE,KAAK;AACL,IAAI,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;AAC3B,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,OAAO,CAAC,GAAG,EAAE;AACf,IAAI,IAAI,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE;AAC9B,MAAM,OAAO,CAAC,CAAC;AACf,KAAK;AACL,IAAI,OAAO,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;AACjC,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,cAAc,GAAG;AACnB,IAAI,OAAO,IAAI,CAAC,OAAO,CAAC,cAAc,EAAE,CAAC;AACzC,GAAG;AACH;;ACjJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AAAO,MAAM,eAAe,CAAC;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,WAAW,CAAC,OAAO,EAAE;AACvB,IAAI,IAAI,OAAO,CAAC,IAAI,EAAE,IAAI,YAAY,EAAE;AACxC,MAAM,MAAM,iDAAiD,CAAC;AAC9D,KAAK;AACL,IAAI,MAAM,YAAY,GAAG,CAAC,CAAC;AAC3B,IAAI,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;AAC3B,IAAI,IAAI,CAAC,GAAG,GAAG,IAAI,WAAW,CAAC,YAAY,CAAC,CAAC;AAC7C,IAAI,IAAI,CAAC,KAAK,GAAG,IAAI,UAAU,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AAC1C,IAAI,IAAI,CAAC,IAAI,GAAG,IAAI,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AACvC,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,cAAc,CAAC,KAAK,EAAE,KAAK,EAAE;AAC/B,IAAI,MAAM,YAAY,GAAG,CAAC,CAAC;AAC3B,IAAI,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC;AACjC,IAAI,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC;AACnC,IAAI,IAAI,IAAI,CAAC,OAAO,CAAC,eAAe,EAAE,GAAG,YAAY,EAAE;AACvD,MAAM,OAAO,KAAK,CAAC;AACnB,KAAK;AACL,IAAI,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,YAAY,CAAC;AACzD,GAAG;AACH,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AAAO,MAAM,eAAe,CAAC;AAC7B;AACA;AACA;AACA;AACA,EAAE,WAAW,CAAC,OAAO,EAAE;AACvB,IAAI,MAAM,YAAY,GAAG,CAAC,CAAC;AAC3B,IAAI,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;AAC3B,IAAI,IAAI,CAAC,GAAG,GAAG,IAAI,WAAW,CAAC,YAAY,CAAC,CAAC;AAC7C,IAAI,IAAI,CAAC,KAAK,GAAG,IAAI,UAAU,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AAC1C,IAAI,IAAI,CAAC,IAAI,GAAG,IAAI,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AACvC,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,EAAE,cAAc,CAAC,CAAC,EAAE;AACpB,IAAI,IAAI,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE;AAC9B,MAAM,OAAO,KAAK,CAAC;AACnB,KAAK;AACL,IAAI,IAAI,EAAE,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AAC1C,IAAI,CAAC,CAAC,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;AACpC,IAAI,CAAC,CAAC,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;AACtC;AACA,IAAI,OAAO,IAAI,CAAC;AAChB,GAAG;AACH,CAAC;;ACnGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AAAO,MAAM,UAAU,CAAC;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,OAAO,qBAAqB,CAAC,QAAQ,EAAE,IAAI,EAAE;AAC/C,IAAI,IAAI,CAAC,IAAI,CAAC,iBAAiB,EAAE;AACjC,MAAM,MAAM,gCAAgC,CAAC;AAC7C,KAAK;AACL,IAAI,IAAI,KAAK,GAAG,CAAC,GAAG,CAAC,QAAQ,GAAG,CAAC,IAAI,IAAI,CAAC,iBAAiB,CAAC;AAC5D,IAAI,OAAO,IAAI,iBAAiB,CAAC,KAAK,CAAC,CAAC;AACxC,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,WAAW,CAAC,GAAG,EAAE,IAAI,EAAE;AACzB,IAAI,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,aAAa,CAAC,IAAI,CAAC;AAClD,MAAM,IAAI,CAAC,iBAAiB,KAAK,SAAS,EAAE;AAC5C,MAAM,MAAM,sDAAsD,CAAC;AACnE,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;AACtB,IAAI,IAAI,CAAC,SAAS,GAAG,CAAC,GAAG,CAAC,UAAU,GAAG,CAAC,IAAI,IAAI,CAAC,iBAAiB,CAAC;AACnE,IAAI,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;AACnB,IAAI,IAAI,CAAC,SAAS,GAAG,IAAI,WAAW,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;AACrD,IAAI,IAAI,CAAC,QAAQ,GAAG,IAAI,WAAW,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;AACpD,IAAI,IAAI,CAAC,OAAO,GAAG,IAAI,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;AACzD,GAAG;AACH;AACA;AACA;AACA;AACA,EAAE,IAAI,GAAG;AACT,IAAI,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;AAC3B,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,IAAI,CAAC,QAAQ,EAAE,MAAM,EAAE;AACzB,IAAI,IAAI,EAAE,GAAG,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;AAC5C,IAAI,IAAI,EAAE,GAAG,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC;AAC7C;AACA,IAAI,IAAI,CAAC,EAAE,GAAG,CAAC,IAAI,IAAI,CAAC,iBAAiB,EAAE,IAAI,EAAE,EAAE;AACnD;AACA,MAAM,OAAO,CAAC,CAAC;AACf,KAAK;AACL;AACA,IAAI,IAAI,GAAG,GAAG,MAAM,IAAI,SAAS,GAAG,MAAM,GAAG,QAAQ,CAAC,MAAM,CAAC;AAC7D;AACA,IAAI,IAAI,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,gBAAgB,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,CAAC,CAAC;AAChE,IAAI,IAAI,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,iBAAiB,EAAE,GAAG,EAAE,EAAE,QAAQ,CAAC,CAAC;AACvE,IAAI,IAAI,WAAW,GAAG,QAAQ,GAAG,UAAU,CAAC;AAC5C;AACA,IAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC,EAAE,IAAI,CAAC,OAAO,EAAE,EAAE,EAAE,UAAU,CAAC,CAAC;AAC1D,IAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,EAAE,UAAU,EAAE,IAAI,CAAC,OAAO,EAAE,CAAC,EAAE,WAAW,CAAC,CAAC;AACnE;AACA;AACA,IAAI,OAAO,CAAC,KAAK;AACjB,MAAM,IAAI,CAAC,SAAS;AACpB,MAAM,CAAC;AACP,MAAM,CAAC,EAAE,GAAG,QAAQ,IAAI,IAAI,CAAC,iBAAiB,EAAE;AAChD,KAAK,CAAC;AACN;AACA,IAAI,OAAO,QAAQ,CAAC;AACpB,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,aAAa,CAAC,MAAM,EAAE,EAAE,EAAE;AAC5B,IAAI,IAAI,EAAE,GAAG,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;AAC5C,IAAI,IAAI,EAAE,GAAG,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC;AAC7C;AACA,IAAI,IAAI,CAAC,EAAE,GAAG,CAAC,IAAI,IAAI,CAAC,iBAAiB,EAAE,IAAI,EAAE,EAAE;AACnD;AACA,MAAM,OAAO,CAAC,CAAC;AACf,KAAK;AACL;AACA,IAAI,IAAI,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,gBAAgB,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,MAAM,CAAC,CAAC;AACnE,IAAI,IAAI,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,iBAAiB,EAAE,GAAG,EAAE,EAAE,QAAQ,CAAC,CAAC;AACvE,IAAI,IAAI,WAAW,GAAG,QAAQ,GAAG,UAAU,CAAC;AAC5C;AACA;AACA,IAAI,IAAI,cAAc,GAAG,IAAI,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE,UAAU,CAAC,CAAC;AACrF,IAAI,IAAI,eAAe,GAAG,IAAI,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,EAAE,WAAW,CAAC,CAAC;AAClF;AACA,IAAI,EAAE,CAAC,cAAc,EAAE,eAAe,CAAC,CAAC;AACxC;AACA;AACA,IAAI,OAAO,CAAC,KAAK;AACjB,MAAM,IAAI,CAAC,SAAS;AACpB,MAAM,CAAC;AACP,MAAM,CAAC,EAAE,GAAG,QAAQ,IAAI,IAAI,CAAC,iBAAiB,EAAE;AAChD,KAAK,CAAC;AACN;AACA,IAAI,OAAO,QAAQ,CAAC;AACpB,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,GAAG,CAAC,QAAQ,EAAE,MAAM,EAAE;AACxB,IAAI,IAAI,EAAE,GAAG,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;AAC5C,IAAI,IAAI,EAAE,GAAG,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC;AAC7C;AACA,IAAI,IAAI,EAAE,IAAI,EAAE,EAAE;AAClB,MAAM,OAAO,CAAC,CAAC;AACf,KAAK;AACL;AACA,IAAI,IAAI,GAAG,GAAG,MAAM,IAAI,SAAS,GAAG,MAAM,GAAG,QAAQ,CAAC,MAAM,CAAC;AAC7D;AACA,IAAI,IAAI,OAAO,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,eAAe,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,CAAC,CAAC;AAC9D;AACA,IAAI,IAAI,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,iBAAiB,EAAE,GAAG,EAAE,EAAE,OAAO,CAAC,CAAC;AACtE,IAAI,IAAI,WAAW,GAAG,OAAO,GAAG,UAAU,CAAC;AAC3C;AACA,IAAI,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,OAAO,EAAE,EAAE,EAAE,QAAQ,EAAE,CAAC,EAAE,UAAU,CAAC,CAAC;AAC1D,IAAI,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,EAAE,QAAQ,EAAE,UAAU,EAAE,WAAW,CAAC,CAAC;AACnE;AACA,IAAI,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,OAAO,IAAI,IAAI,CAAC,iBAAiB,EAAE,CAAC,CAAC;AAC/E;AACA,IAAI,OAAO,OAAO,CAAC;AACnB,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,KAAK,GAAG;AACV,IAAI,IAAI,EAAE,GAAG,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;AAC5C,IAAI,IAAI,EAAE,GAAG,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC;AAC7C;AACA,IAAI,OAAO,EAAE,IAAI,EAAE,CAAC;AACpB,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,EAAE,IAAI,GAAG;AACT,IAAI,IAAI,EAAE,GAAG,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;AAC5C,IAAI,IAAI,EAAE,GAAG,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC;AAC7C;AACA,IAAI,OAAO,CAAC,EAAE,GAAG,CAAC,IAAI,IAAI,CAAC,iBAAiB,EAAE,IAAI,EAAE,CAAC;AACrD,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,EAAE,QAAQ,GAAG;AACb,IAAI,OAAO,IAAI,CAAC,SAAS,GAAG,CAAC,CAAC;AAC9B,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,cAAc,GAAG;AACnB,IAAI,IAAI,EAAE,GAAG,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;AAC5C,IAAI,IAAI,EAAE,GAAG,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC;AAC7C,IAAI,OAAO,IAAI,CAAC,eAAe,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;AACxC,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,eAAe,GAAG;AACpB,IAAI,IAAI,EAAE,GAAG,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;AAC5C,IAAI,IAAI,EAAE,GAAG,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC;AAC7C,IAAI,OAAO,IAAI,CAAC,gBAAgB,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;AACzC,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,eAAe,CAAC,EAAE,EAAE,EAAE,EAAE;AAC1B,IAAI,OAAO,CAAC,EAAE,GAAG,IAAI,CAAC,iBAAiB,EAAE,GAAG,EAAE,IAAI,IAAI,CAAC,iBAAiB,EAAE,CAAC;AAC3E,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,gBAAgB,CAAC,EAAE,EAAE,EAAE,EAAE;AAC3B,IAAI,OAAO,IAAI,CAAC,QAAQ,EAAE,GAAG,IAAI,CAAC,eAAe,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;AAC1D,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,iBAAiB,GAAG;AACtB,IAAI,OAAO,IAAI,CAAC,SAAS,CAAC;AAC1B,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,KAAK,CAAC,KAAK,EAAE,YAAY,EAAE,MAAM,EAAE,aAAa,EAAE,IAAI,EAAE;AAC1D,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,EAAE,CAAC,EAAE,EAAE;AACnC,MAAM,MAAM,CAAC,aAAa,GAAG,CAAC,CAAC,GAAG,KAAK,CAAC,YAAY,GAAG,CAAC,CAAC,CAAC;AAC1D,KAAK;AACL,GAAG;AACH,CAAC;;;;;;;;;;"}